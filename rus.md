# Чуть больше SASS для (БЭ)Модификаторов

В начале 2013 года синтаксис «Блок, Элемент, Модификатор» (БЭМ), применяемый к
CSS, [стал][1] популярной методологией организации кода, добавляющей 
единообразие в проекты. В целом, я люблю БЭМ. Он хорошо структурирован, и это 
важно. Единственное, что меня волновало все это время (и не только меня, но и 
[моих коллег разработчиков][2]) — это то, насколько длинными и избыточными
становились значения атрибута `class` у элементов — особенно, когда дело 
доходило до модификаторов.

	<button class="button button--green button--rounded button--large">
	
## Обосоленные модификаторы: сокращенный синтаксис

Мне действительно нравится наглядная запись вида `элемент--модификатор`. Она 
помогает понять, что класс предназначен только для расширения каких-либо
свойств элемента. Однако дублирование названия элемента избыточно. Мы можем 
избежать этого *и* визуально отделить модификаторы, добавив их к элементам
непосредственно в таблицах стилей, сохранив при этом дефис в начале имени 
класса, чтобы показать, что он является модификатором.

HTML

	<button class="button -green -rounded -large">
	
SCSS

	.button {
		&.-green {...}
		&.-rounded {...}
		&.-large {...}
	}
	
Такой ход обеспечивает наглядное отделение элементов и модификаторов, позволяя
избежать повторение имени класса. Да, использование дефиса в качестве первого
символа в селекторе валидно ([а вот использование двойного дефиса — нет][3]). 
Если вас беспокоят селекторы по нескольким классам, возможно, у вас остались
плохие воспоминания со времен IE6. Но вам больше не нужно о нем беспокоиться.

Дополнительная специфичность, возникающая при таком подходе, казалось бы, также
может показаться проблемой. Однако я ее таковой не считаю, хотя и представляю 
ситуацию, в которой у вас есть несколько глобальных переопределяющих правил, 
которые вы хотели бы применять к любому элементу. В этом случае вам необходимо 
сделать что-то в таком духе:

SCSS

	.button {
		&.-hoverable {
			&:hover {
				opacity: 0.75;
			}
		}
	}
 
	.overrides {
		&.-disabled {
			opacity: 0.25;
		}
	}
	
HTML

	<button class="button -hoverable overrides -disabled">Disabled</button>
	
Пример выдуманный, но вы поняли смысл. При наведении курсора на кнопку ее 
прозрачность не изменяется, потому что свойства, определенные для селектора 
`.button.-hoverable`, перекрывается свойствами, указанными для селектора 
`.overrides.-disabled`, обладающего той же специфичностью, но определенного
позже.

## Сохраненные вариации: расширение с помощью SASS

Гибкость использования модификаторов в разметке — это круто, но когда я замечаю 
часто повторяющиеся группы свойств, я предпочитаю комбинировать их в CSS. 
Директива @extend в SASS позволяет это сделать.

SCSS

	.button--save {
		@extend %button;
		@extend %button--large;
		@extend %button--rounded;
		@extend %button--green;
	}
	
HTML

	<button class="button--save">Save</button>
	
Весьма наглядно! В этом фрагменте вы, возможно, обратили внимание на пару 
факторов: 1) Я использую [селектор-плейсхолдер][4] % в SASS и 2) я все еще 
использую обычный синтаксис БЭМ `элемент--модификатор`.

Сначала я определяю все свои стили для селектора-плейсхолдера, таким образом, я
могу расширить их для других классов с помощью директивы @extend.

	%button {
		background: #45beff;
		border: none;
		padding: 1em 2em;
		font-size: 16px;
		
		&:hover {
		    opacity: 0.75;
		}
	}
 
	%button--green {
		background: #3efa95;
	}
	
	%button--red {
		background: #ff3a6a;
	}
 
	%button--large {
		font-size:20px;
	}
 
	%button--rounded {
		border-radius: 10px;
	}
	
Теперь я могу собрать все стили для элемента, добавляя модификаторы, *которые
я планирую испльзовать в разметке*, а также создавать вариации, которые можно
использовать повторно и расширять за счет сочетания модификаторов.

	.button {
		@extend %button;
 
		&.-green {
			@extend %button--green;
		}
  
		&.-large {
			@extend %button--large;
		}
	}
 
	.button--delete {
		@extend %button;
		@extend %button--large;
		@extend %button--rounded;
		@extend %button--red;
	}
	
[Посмотреть пример на CodePen.][5]

## От БЭМ к БЭВМ?

После всего, что сказано и сделно выше, паттерн БЭМ `блок__элемент--модификатор` 
трансформировался во что-то более похожее на 
`блок__элемент--вариация -модификатор` (БЭВМ), дополненное внутренними 
SASS-селекторами вида `%модификатор`.

	// Внутренний модификатор
	%button--red {
		background: #ff3a6a;
	}
 
	// Элемент
	.button {
		// Модификатор
		&.-red {
			@extend %button--red;
		}
	}
 
	// Вариация
	.button--delete {
		@extend %button;
		@extend %button--red;
	}
	
Мне все это нравится, а вы что думаете? Удобно? Странно? Давайте обсудим!

[1]: http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/
[2]: http://viget.com/extend/bem-multiple-modifiers-and-experimenting-with-attribute-selectors
[3]: http://www.w3.org/TR/CSS2/syndata.html#characters
[4]: http://blog.teamtreehouse.com/extending-placeholder-selectors-with-sass
[5]: http://codepen.io/greypants/pen/hvrHb
